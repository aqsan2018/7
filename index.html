<script>
document.addEventListener('DOMContentLoaded', () => {
    const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

    const container = document.getElementById('container');
    const instructions = document.getElementById('instructions');
    const finalMessage = document.getElementById('final-message');
    const clickCounter = document.getElementById('click-counter');
    const boopSound = document.getElementById('boop-sound');
    const revealSound = document.getElementById('reveal-sound');

    const worldWidth = window.innerWidth;
    const worldHeight = window.innerHeight;
    const emojiSize = 30;
    const clicksToReveal = 100;
    let clickCount = 0;
    let messageRevealed = false;

    const emojis = ['ðŸ’‹', 'â¤ï¸', 'ðŸ˜˜', 'ðŸ’•', 'ðŸ’–', 'ðŸ’ž'];

    // Matter.js engine setup
    const engine = Engine.create({ gravity: { y: 0.4 } });
    const world = engine.world;

    // Create renderer (weâ€™ll override drawing)
    const render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: worldWidth,
            height: worldHeight,
            wireframes: false,
            background: 'transparent'
        }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // Walls
    const wallOptions = { isStatic: true, render: { visible: false } };
    World.add(world, [
        Bodies.rectangle(worldWidth / 2, worldHeight + 30, worldWidth + 100, 60, wallOptions),
        Bodies.rectangle(-30, worldHeight / 2, 60, worldHeight, wallOptions),
        Bodies.rectangle(worldWidth + 30, worldHeight / 2, 60, worldHeight, wallOptions)
    ]);

    // Custom rendering hook for emoji
    const emojiBodies = new Map();

    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        ctx.font = `${emojiSize}px "Segoe UI Emoji", "Apple Color Emoji", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        emojiBodies.forEach((emoji, body) => {
            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            ctx.fillText(emoji, 0, 0);
            ctx.restore();
        });
    });

    function addEmoji(x, y) {
        if (messageRevealed) return;

        clickCount++;
        clickCounter.textContent = `Kisses: ${clickCount}`;
        boopSound.currentTime = 0;
        boopSound.play().catch(() => {});

        const emoji = emojis[Math.floor(Math.random() * emojis.length)];

        const body = Bodies.circle(x, y, emojiSize / 2, {
            restitution: 0.6,
            friction: 0.3,
            density: 0.01
        });
        World.add(world, body);
        emojiBodies.set(body, emoji);

        if (clickCount === 1) {
            instructions.style.transition = 'opacity 0.5s';
            instructions.style.opacity = '0';
        }

        if (clickCount >= clicksToReveal && !messageRevealed) {
            messageRevealed = true;
            finalMessage.style.opacity = '1';
            revealSound.play().catch(() => {});
        }
    }

    container.addEventListener('mousedown', e => addEmoji(e.clientX, e.clientY));
    container.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.touches[0];
        addEmoji(touch.clientX, touch.clientY);
    }, { passive: false });

    window.addEventListener('resize', () => location.reload());
});
</script>
